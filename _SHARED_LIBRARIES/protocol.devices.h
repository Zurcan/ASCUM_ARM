#ifndef __DEVTYPE_
#define __DEVTYPE_
#include  "stdint.h"
#include  "version.h"


#define         devSIGNATURE_SIZE    32
#define         devNAME_SIZE         32

#define         BootloaderSig              "Bootloader_v1.0________________"
#define         BootloaderSig3             "Bootloader_v3.0________________"


//======================================================================
//      СОГЛАШЕНИЕ О ВНУТРЕННЕЙ ИДЕНТИФИКАЦИИ БЛОКОВ
//   
//======================================================================
//   1.  СОКРАЩЕНИЯ
//
//     АИ  - аппаратный идентификатор
//     СВИБ - СОГЛАШЕНИЕ О ВНУТРЕННЕЙ ИДЕНТИФИКАЦИИ БЛОКОВ.
//     ПО  - программное обеспечение.
//     СПО - системное программное обеспечение.
//     ППО - прикладное программное обеспечение.
//     ИППО- идентификатор ППО (Хэш значение по названию ППО).
//     ПАП - программно-аппаратная платформа
//     ИЗУ - идентификационная запись устройства
//     HWID- Hardware Identifier
//
//   2.  ЦЕЛИ
//
//    Данное соглашение имеет своей целью организовать процесс назначения
//  идентификаторов, сигнатур, версий, ревизий и других идентификационных
//  данных в единую систему удовлетворяющую следующим требованиям:
//    *. однозначная идентификация аппаратной части устройства;
//    *. однозначная идентификация возможностей СПО (идентификация ПАП);
//    *. хранение технологического и серийного номеров устройства;
//    *. невозможность использования ППО не предназначенного для аппаратуры
//       или ПАП целевого устройства;
//    *. контроль версии СПО устройства;
//    *. контроль версии ППО устройства;
//    *. возможность использования одной аппаратуры и ПАП с разным ППО;
//    *. идентификация устройства как функционального элемента для автоматического 
//       подключения драйвера устройства в БКС;
//    *. однозначное определение совместимости образа ППО с аппаратурой и ПАП;
//    *. обратная совместимость системной записи (signature);
//    *. контроль образа целостности СПО и ППО;
//    *. символьное и нумерическое название ППО;
//    *. методика быстрого обнаружения блоков в сети RS-485
//    
//
//   3.  НАЗНАЧЕНИЕ АППАРАТНОГО ИДЕНТИФИКАТОРА И СИГНАТУРЫ УСТРОЙСТВА
//    цели:
//    *. однозначная идентификация аппаратной части устройства;
//    *. однозначная идентификация возможностей СПО (идентификация ПАП);
//    *. невозможность использования ППО не предназначенного для аппаратуры;
//    *. однозначное определение совместимости образа ППО с аппаратурой и ПАП;
//
//    Устройства, использующие протокол обмена MIO по сети должны иметь
//  ряд признаков которые позволяют устройству управления (системе верхнего
//  уровня) однозначно идентифицировать тип устройства, его аппаратную ревизию.
//    Для реализации используются ИДЕНТИФИКАТОР (ID) и СИГНАТУРА(SIGNATURE).
//  Идентификатор содержит код устройства и номер его модификации
//  Формат идентификатора ID
//        0 x D D P R - 16 бит слово
//    где D - код устройства
//        P - код аппаратно-программной платформы устройства
//        R - код ревизии устройства (4 bit)
//        
//    Коды устройств:
//       10   - БКС       
//		   11   - USB-BKS 
//       20   - Устройство регистрации данных
//       40   - БЦС
//       41   - КБЦС
//       42   - БАРС
//       43   - БУН
//       44   - Термометр 6 датчиков DS1821
//       50   - БАС
//       60   - РПУ (приемник ПДУ)
//       61   - ПДУ-П
//       62   - ПДУ-У
//       63   - ПДУ-УА
//       70   - БРК
//       80   - Модули DIM AIM и т.п.
//       A0   - УППР
//       A1   - ТП2-250
//       E0   - Дисплей отображения параметров
//       E1   - Дисплей 7~	VSX 6154
//       E2   - Дисплей 10~     VSX 6154
//       E3   - Дисплей 10~     BlueShark
//        
//       99  - Сервисные устройства системы
//         990 - устройство обновления ПО
//         998 - отладочный модуль
//
//
//    Сигнатура имеет символьный формат (строка) длиной 32 байт и записывается
//  следующим образом:
//        
//      DDDDDDDDDDDDDDDDDpPP_rNN_SSSS_K
//    где DDDD... - Символьное обозначение устройства лат. буквами
//                  должно совпадать с официальным названием устройства
//        PP      - Версия программно-аппаратной платформы
//        NN      - Номер ревизии блока, однозначно идентифицирует тип устройства.
//                  назначается по аппаратной ревизии устройства
//        SSSS    - Дополнительное поле.
//        K       - Дополнительное цифровое поле.
//    Дополнительные поля могут быть заполнены по усмотрению разработчика.
//  Сигнатура не должна содержать знаков ПРОБЕЛ, при необходимости использования
//  заменяется на знак "_"
//    Назначение аппаратного идентификатора производится по его целевой функции,
//  Т.е если изделие дисплей и может выполнять целевую функцию дисплея, тогда его
//  идентификатор должен быть "E0 - Дисплей".
//    Если изделие аппаратно сильно отличается от аналога тогда допускается создание
//  нового аппаратного идентификатора устройтства. При этом следует помнить, что
//  увеличение количества идентификаторов устройств влечет за собою заполнение
//  диаппазона нумерации.
//
//   3.1  НУМЕРАЦИЯ РЕВИЗИЙ И ПЛАТФОРМ
//
//    Нумерация ревизий устройства начинается с единицы. Следующее изменение устройства
//  должно увеличивать номер ревизии на 1. Смена номера ревизии производится при
//  изменении аппаратной части устройства и т.п. При этом специфика использования
//  устройства в ревизии не отражается. Т.е. если БЦС установлен в специфичных условиях
//  и выполняет нестандартные функции, запрограммирован специфичным прикладным П.О., то
//  номер аппаратной ревизии не допускается использовать для идентификации подтипа
//  блока, с целью привязки блока к специфичному ПО.
//
//    Нумерация платформ производится начиная с единицы. При этом каждая новая платформа
//  является представителем серьезных системных изменений как в части структур данных
//  так и в части идей и алгоритмов. Каждое ПО в рамках платформы ДОЛЖНО иметь старшим
//  номером версии номер используемой платформы.
//
//   3.2  ПРОГРАММНО - АППАРАТНАЯ ПЛАТФОРМА
//
//    Программно-аппаратная платформа (ПАП) устройства это совокупность аппаратных
//  средств устройства и системного программного обеспечения, установленного
//  на нем. ПАП предназначена для идентификации глобальной принадлежности системного
//  ПО к семейству, т.е. ПАП позволяет определить набор системных функций и комманд,
//  набор системных структур данных и т.п.
//    Для организации максимальной обратной совместимости устройств, а также  
//  для обеспечения максимальной надежности взаимодействия их между собой, системное
//  и прикладное ПО для них развивается семействами или платформами. При этом номер
//  используемой платформы - есть номер старшей версии ПО.
//    ПО устройств разного назначения, принадлежащее одной платформе полностью совме-
//  стимо между собой, использует одни и те же системные принципы, структуры данных и
//  функции. Все изменения, вносимые в ПО не могут менять структур системных данных,
//  отключать функции платформы и т.п.
//    Т.к. основной набор системных функций, кроме быстрого поиска устройств предо-
//  ставляется системным загрузчиком, также как и HWID и Signature, то именно он
//  возвращает номер используемой ПАП. При этом использование прикладного ПО, предна-
//  значенного для другой ПАП в устройстве запрещен и отслеживается загрузчиком.
//  В случае же запуска такого приложения возможна некорректная его работа!!!
//
//   3.3. ИДЕНТИФИКАЦИОННАЯ ЗАПИСЬ УСТРОЙСТВА
//
//   3.4. КОНТРОЛЬ СОВМЕСТИМОСТИ ППО с аппаратурой и ПАП
//  цели:
//    * невозможность использования ППО не предназначенного для аппаратуры
//       или ПАП целевого устройства;
//    * совместимость ППО с рядом устройств.
//    * механизм ограничения совместимости ППО для более старых устройств
//    * механизм ограничения совместимости ППО для более новых устройств
//    ИЗУ каждой ППО содержит HWID целевого усройства. На его снове реализован
//  контроль совместимости ППО с аппаратурой и ПАП. Загрузчик проверяет HWID
//  из ИЗУ ППО со своим HWID или с таблицей HWID других устройств с которыми он
//  АБСОЛЮТНО совместим и в случае совпадения загрузчик может запустить ППО, иначе
//  ППО считается непригодным для работы на устройстве и игнорируется.
//    Для обеспечения совместимости ППО с несколькими устройствами (например ПО 
//  монитора v3 работает на 0xE141,0xE142,0xE241,0xE244 и т.д. В этом случае в тело
//  ППО вносится еще одна запись compatibilityList. Она содержит таблицу совместимых
//  идентификаторов аппаратуры. Идентификатор из ИЗУ в таблице не указывается.
//  Каждый из HWID из таблицы проверяется загрузчиком так же, как HWID из ИЗУ ППО.
//
//   3.5 МЕХАНИЗМ ПОДКЛЮЧЕНИЯ БЛОКОВ К СИСТЕМЕ.
//       КОНТРОЛЬ СОВМЕСТИМОСТИ БЛОКОВ.
//  цели:
//    * обеспечить правильное функционирование системы во времени (замена блоков)
//    * избежать неправильного подключения блоков и ошибочной трактовки полученных
//      данных.
//    * создать связки многофункциональных устройств (монитор, БКС...)
//    * обеспечить совместимость более новых с более старыми устройствами при их 
//      развитии.
//    Драйвер каждого типа блока настроен на конкретный идентификатор обслуживаемого
//  блока (HWID). Начальное состояние драйвера - режим поиска целевого устройства. В этом
//  режиме драйвер производит периодические запросы идентификационной записи (ИЗУ) 
//  по заданному адресу. Не отвечающее устройство помечается как отключенное. Если 
//  получен ответ тогда производится анализ аппаратного идентификатора ответившего
//  устройства.
//    В случае совпадения идентификатора идентификатором драйвера он переводится в
//  режим проверки ППО блока на соответствие требуемой функции.
//    В случае несовпадения идентификаторов блока и драйвера, драйвер сравнивает HWID
//  блока со списком HWID которые он может обработать и если не обнаруживает производит 
//  запрос блока для перевода его в режим совместимости с необходимым. При получении
//  подтверждения включения режима совместимости драйвер переходит в режим проверки 
//  ППО блока на соответствие требуемой функции.
//    Если получен ответ о несовместимости блока с устройством описанным идентификато-
//  ром драйвера, тогда драйвер передает ошибку модулю подключения и "завешивает" 
//  связь с блоком, периодически запрашивая его идентификатор для контроля связи.
//    Если драйвер не устанавливает ограничение на идентификатор ППО устройства,
//  или версия ИЗУ, используемая устройством, не поддерживает передачи ИППО, 
//  тогда переход в режим проверки ППО блока автоматически помечает устройство как
//  подключенное переводит в режим целевого взаимодействия.
//    В случае привязки драйвера к ИППО производится анализ ИЗУ, и сравнивается 
//  указанный в драйвере/драйверу ИППО с ИППО в ИЗУ. Если ИППО совпали, тогда драйвер
//  помечает устройство как подключенное переводит в режим целевого взаимодействия.
//    Если ИППО не совпали тогда целевому блоку передается сообщение о несовместимости
//  его ППО и "завешивает" связь с блоком, периодически запрашивая его идентификатор 
//  для контроля связи. 
//    В процессе подключения устройства любые ошибки связи приведут к повтору процедуры
//  с подключения с самого начала. Если устройство подключенно, тогда лишь продолжи-
//  тельная серия из 6 не ответов приведет к его отключению и соответственно инициирует
//  процесс подключения.
//
//   4. ОБНАРУЖЕНИЕ БЛОКОВ В СЕТИ
//    цели:
//      * возможность быстрого обнаружения блоков и построения конфигурации сети
//      * обнаружение конфликтов адресов блоков
//    ! Описываемый механизм обнаружения блоков не доступен в системном загрузчике,
//  поэтому для обнаружения такого блока должен быть использованн перебор адресов или
//  указан точный адрес устройства.
//    Для обнаружение присутствия и работоспособности блоков в сети используется
//  алгоритм временного разделения адресов. Т.е. каждому значению адреса выделя-
//  ется интервал времени (тайм-слот) для ответа о своем присутствии запрашивающему.
//  Тайм-слот имеет длительность 521 мкс.
//
//  QQQ___________________________________________________________________
//  ___| Tblank | Tblank |  TS 0  |  TS 1  |  TS 2  |  TS 3  |  ...
//
//    Первые два тайм-слота зарезервированны для формирования отступа от момента
//  приема комманды и упрощения принимающей стороне разобрать эхо запроса и 
//  поступающие ответы.
//    Для обеспечения обнаружения устройств с одинаковыми адресами, вызывающих
//  конфликты в ЛС тайм-слот делится на три равные части суб-слоты(sub-TS)
//   
//     |______sub_TS_1_______|_______sub_TS_2_______|________sub_TS_3_______|
//
//    Выбор субслота для ответа каждым блоком сети производится случайным образом.
//  Т.е. блоки с одинаковыми адресами с высокой вероятностью в течение нескольких
//  запросов ответят в разных суб-слотах, что позволит определить наличие двух адресатов
//  в системе.
//    После выбора тайм-слота и суб-слота производится выдерживание паузы для попадания
//  в него и отправка 1 байта - собственного адреса устройства
//
//========================================================================

// ***********************************************************************
// Устройства АСК-УМ
// ***********************************************************************

#define   DigitalInOutBlock                 0x7002
#define   DigitalInOutBlockSig              "DIG_IN_16_OUT_10_V2____________"
                                         
#define   AnalogInput16Block                0x7003
#define   AnalogInput16BlockSig             "ANALOG_IN_16_V2________________"
                                         
// Устройства первой ревизии             
                                         
#define   DigitalInOutBlock_r1              0x4001
#define   DigitalInOutBlockSig_r1           "DIG_IN_16_OUT_10_V2_R1_________"
                                         
#define   AnalogInput16Block_r1             0x5001
#define   AnalogInput16BlockSig_r1          "ANALOG_IN_16_V2_R1_____________"
                                         
#define   UPPR                              0xA001
#define   UPPRSig                           "UPPR_V1________________________"
                                         
#define   RemoteControlBlock_nr             0x6001
#define   RemoteControlBlockSig_nr          "REMOTE_IN_V1_NR________________"
                                         
#define   DisplayModule_nr                  0xF1F0
#define   DisplayModuleSig_nr               "DISPLAY_MODULE_R1______________"

// Устройства второй ревизии

#define   DigitalInOutBlock_r2              0x4002
#define   DigitalInOutBlockSig_r2           "DIG_IN_16_OUT_10_V2_R2_________"

#define   AnalogInput16Block_r2             0x5002
#define   AnalogInput16BlockSig_r2          "ANALOG_IN_16_V2_R2_____________"

#define   SystemControlBlock_r2             0x1002
#define   SystemControlBlockSig_r2          "SYSTEM_CTRL_V2_R2______________"
#define   SystemControlBlockBootSig_r2      "SYSTEM_CTRL_V2_R2________BOOT__"

#define   DisplayModule_r2                  0xE002
#define   DisplayModuleSig_r2               "DISPLAY_MODULE_R2______________"

#define   DisplayModule_r3                  0xE003
#define   DisplayModuleSig_r3               "DISPLAY_MODULE_R3______________"

#define   DisplayModule_AL                  0xE000
#define   DisplayModuleSig_AL               "DISPLAY_MODULE_MACHINE_AL______"

#define   RemoteControlBlock_r2             0x6002
#define   RemoteControlBlockSig_r2          "REMOTE_IN_V1_R2________________"

// Устройства третьей ревизии

#define   SystemControlBlock_r3             0x1003
#define   SystemControlBlockSig_r3          "SYSTEM_CTRL_V2_R3______________"
#define   SystemControlBlockBootSig_r3      "SYSTEM_CTRL_V2_R3________BOOT__"
                                                 
#define   RemoteControlBlock_r3             0x6003
#define   RemoteControlBlockBootSig_r3      "REMOTE_IN_V1_R3__________BOOT__"
#define   RemoteControlBlockSig_r3          "REMOTE_IN_V1_R3________________"
                                                 
#define   DigitalInOutBlock_r3              0x4003
#define   DigitalInOutBlockBootSig_r3       "DIG_IN_16_OUT_10_V2_R3___BOOT__"
#define   DigitalInOutBlockSig_r3           "DIG_IN_16_OUT_10_V2_R3_________"

#define   AnalogInput16Block_r3             0x5003
#define   AnalogInput16BlockBootSig_r3      "ANALOG_IN_16_V2_R3_______BOOT__"
#define   AnalogInput16BlockSig_r3          "ANALOG_IN_16_V2_R3_____________"
                                                 
#define   RemoteControlBlock_r4             0x6004
#define   RemoteControlBlockBootSig_r4      "REMOTE_IN_V1_R4__________BOOT__"
#define   RemoteControlBlockSig_r4          "REMOTE_IN_V1_R4________________"

// Дополнительные устройства
#define   UpdateModule                      0x9900

#define   DebugModule                       0x9980
#define   DebugModuleSig                    "DEBUG_MODULE___________________"


//
// Новая система назначения имен используется с этой метки
// Новая версия платформы "p4"
//                                           DDDDDDDDDDDDDDDDDDpMM_rNN_SSSS_K
#define   XXX_rX_p4                         0x0040

#define   BKS_r3_p4                         0x1043
#define   BKS_r3_p4_Sig                     "BKS_______________p4__r3_______"
#define   BKS_r3_p4_Name                    "БКС-04(Блок контроля системы)  "

#define   BKS_r4_p4                         0x1044
#define   BKS_r4_p4_Sig                     "BKS_______________p4__r4_______"
#define   BKS_r4_p4_Name                    "БКС-05(Блок контроля системы)  "

#define   BKS_r8_p4                         0x1048
#define   BKS_r8_p4_Sig                     "BKSRC_____________p4__r8_______"
#define   BKS_r8_p4_Name                    "БКС-06РС(Блок контроля системы)"

#define   USBBKS_r1_p4                      0x1141
#define   USBBKS_r1_p4_Sig                  "USBBKS____________p4__r1_______"
#define   USBBKS_r1_p4_Name                 "USB-БКС-01 (Блок связи с BKS)  "


#define   SVRP_                             0x2000
#define   SVRP_r1_p4                        0x2041
#define   SVRP_r1_p4_Sig                    "SVRP______________p4__r1_______"
#define   SVRP_r1_p4_Name                   "СВРП-01 (Видео регистратор)    "


#define   BRK_r1_p4                         0x7041
#define   BRK_r1_p4_Sig                     "BRK_______________p4__r1________"
#define   BRK_r1_p4_Name                    "БРК-01 (Блок радио комманд)     "

#define   BCS_03xx_r3_p4                    0x4043
#define   BCS_03xx_r3_p4_Sig                "BCS_______________p4__r3________"
#define   BCS_03xx_r3_p4_Name               "БЦС-06 (Блок цифровых сигналов) "

#define   KBCS_03xx_r3_p4                   0x4143
#define   KBCS_03xx_r3_p4_Sig               "KBCS______________p4__r3________"
#define   KBCS_03xx_r3_p4_Name              "KБЦС-06(Контр.цифровых сигналов)"

#define   BUN_r2_p4                         0x4341
#define   BUN_r2_p4_Sig                     "BUN_______________p4__r1________"
#define   BUN_r2_p4_Name                    "БУН-01 (Блок управления насосом)"

#define   BAS_02_r2_p4                      0x5042
#define   BAS_02_r2_p4_Sig                  "BAS_______________p4__r2________"

#define   BARS_r1_p4                        0x4241
#define   BARS_r1_p4_Sig                    "BARS______________p4__r1________"

#define   Display_r4_p4                     0xE044
#define   Display_r4_p4_Sig                 "DISPLAY___________p4__r4________"

#define   Display_10_V6372_r5_p4            0xE045
#define   Display_10_V6372_r5_p4_Sig        "10`_V6372_DISPLAY_p4__r5________"

#define   Display_7_V6154_r1_p4             0xE141
#define   Display_7_V6154_r1_p4_Sig         "7`_V6154_DISPLAY__p4__r1________"

#define   Display_7_V6154_r2_p4             0xE142
#define   Display_7_V6154_r2_p4_Sig         "7`_V6154_DISPLAY__p4__r2________"

#define   Display_10_V6154_r1_p4            0xE241
#define   Display_10_V6154_r1_p4_Sig        "10`_V6154_DISPLAY_p4__r1________"

#define   Display_10_V6154_r4_p4            0xE244
#define   Display_10_V6154_r4_p4_Sig        "10`_V6154_DISPLAY_p4__r4________"

#define   Display_10_BLUSHA_r4_p4           0xE341
#define   Display_10_BLUSHA_r4_p4_Sig       "10`_BLUESHARK_DISPLAY_p4__r1____"


#define   DebugModule_r1_p4                 0x99C1
#define   DebugModuleSig_r1_p4              "USB_DEBUG_MODULE_______________"
#define   DebugModule_r1_p4_Name            "USB отладочный модуль          "

#define   TP2_r1_p4                         0xA141
#define   TP2_r1_p4_Sig                     "TP2ML_____________p4__r1________"
#define   TP2_r1_p4_Name                    "ТП2-250МЛ (контроллер преобраз.)"

#define   TP2_r2_p4                         0xA142
#define   TP2_r2_p4_Sig                     "TP2-250MM_________p4__r2________"
#define   TP2_r2_p4_Name                    "ТП2-250ММ(контроллер преобраз.) "
         
#define   PDU_P_r1_p4                       0x6141
#define   PDU_P_r1_p4_Sig                   "PDU_P_____________p4__r1________"
#define   PDU_P_r1_p4_Name                  "ПДУ-П (Блок ПДУ крана)          "

#define   RPDU_P_r1_p4                      0x6141
#define   RPDU_P_r1_p4_Sig                  "PDU_P_____________p4__r1________"
#define   RPDU_P_r1_p4_Name                 "ПДУ-П (Релейный приемный блок)  "

#define   RPDU_U_r1                         0x6201
#define   RPDU_UA_r1                        0x6201

#define   BCS_r11_p4                        0x404B
#define   BCS_r11_p4_Sig                    "BCS_______________p4__r11_______"
#define   BCS_r11_p4_Name                   "БЦС-11 (Блок цифровых сигналов) "
// Блок цифровых сигналов на STM32 с аналоговыми входами и новыми ключами BTT6050-2EKA

#define   DIM_r1                            0x8041
#define   DIM_r1_Sig                        "DIM_______________p4_r1_________"
//                                           12345678901234567890123456789012
#define   AIM_r1                            0x8141
#define   DOM_r1                            0x8341

/*struct mSignature{
   uint16_t   ID;
   uint16_t   verID;
   uint8_t    Signature[devSIGNATURE_SIZE];
   uint8_t    nc0;
   uint8_t    Name[devNAME_SIZE];
   uint8_t    nc1;
};*/

//#ifndef __KEIL__
//#define __packed
//#endif
/*   SIGNATURE new version
__packed struct mSignature{
   //----------------------------------------------------------------
   // System information
   uint16_t   ID;
   uint16_t   tablesCRC16;
   uint32_t   flags;
      #define msf__SIGNATURE_V2        0x40000000;
      #define msf__BloadSupport        0x00000001;
      #define msf__ApplicationStarted  0x00000002;
   //----------------------------------------------------------------
   // Boot system information
   uint16_t   bootSystemID;
   uint16_t   bootVersion;
   uint32_t   serialNo;
   //----------------------------------------------------------------
   // Application information
   uint16_t   softwareCRC16;   //CRC32 of application programm
   uint32_t   softwareSize;    //size of application programm
   uint16_t   softwareVersion;
   uint8_t    reserved[16];
   //----------------------------------------------------------------
   // Naming, string information
   uint8_t    Signature[devSIGNATURE_SIZE];
   uint8_t    nc0;
   uint8_t    Name[devNAME_SIZE];
   uint8_t    nc1;
};
*/
struct __attribute__ ((packed)) mSignature{
   //----------------------------------------------------------------
   // System information
   uint16_t   ID;
   uint16_t   tablesCRC16;
   uint32_t   flags;
      #define msf__BloadSupport        0x00000001
      #define msf__ApplicationStarted  0x00000002
   //----------------------------------------------------------------
   // Boot system information
   uint16_t   bootSystemID;

   //----------------------------------------------------------------
   // Application information
   uint16_t   serialNo;
   uint16_t   softwareCRC16;   //CRC32 of application programm
   uint32_t   softwareSize;    //size of application programm
   
   uint8_t    reserv2[6];

   //----------------------------------------------------------------
   // Naming, string information
   uint8_t    Signature[devSIGNATURE_SIZE];
   uint8_t    nc0;
   uint8_t    Name[devNAME_SIZE];
   uint8_t    nc1;
};

struct __attribute__ ((packed)) m2Signature{
   //----------------------------------------------------------------
   // System information
   uint16_t   ID;
   uint16_t   tablesCRC16;
   uint32_t   flags;
      #define msf__BloadSupport        0x00000001
      #define msf__ApplicationStarted  0x00000002
      #define msf__V2REC               0x40000000
   //----------------------------------------------------------------
   // Boot system information
   uint16_t   bootSystemID;

   //----------------------------------------------------------------
   // Application information
   uint16_t   techNumber;
   uint16_t   softwareCRC16;   //CRC32 of application programm
   uint32_t   softwareSize;    //size of application programm
   uint32_t   serialNumber;
   uint8_t    reserv2[2];

   //----------------------------------------------------------------
   // Naming, string information
   uint8_t    Signature[devSIGNATURE_SIZE];
   uint8_t    nc0;
   uint8_t    Name[devNAME_SIZE];
   uint8_t    nc1;
   //----------------------------------------------------------------
   // VersionInfo
   uint8_t    major;
   uint8_t    minor;
   uint8_t    beta;
   uint16_t   build;
   uint32_t   date;
   uint8_t    reserv3[29];
#ifdef __arm__arm__
   m2Signature(){for(int i=0;i<sizeof(m2Signature);i++)((char*)(&ID))[i]=0;}
   void     clear(){for(int i=0;i<sizeof(m2Signature);i++)((char*)(&ID))[i]=0;}
#endif
};

struct __attribute__ ((packed)) m3Signature{
   //----------------------------------------------------------------
   // System information
   uint16_t   ID;
   uint16_t   tablesCRC16;
   uint32_t   flags;
      #define msf__BloadSupport        0x00000001
      #define msf__ApplicationStarted  0x00000002
      #define msf__ApplicationCorrupt  0x00000004
      #define msf__ApplicationIncompat 0x00000008
      #define msf__NoApplication       0x00000010
      #define msf__HARDWARE_ERROR      0x00000100
      #define msf__PRODUCTION_ERROR    0x00000200
      #define msf__Want_be_Master      0x08000000 // flag set if device want to be bus master
      #define msf__V2REC               0x40000000
      #define msf__V3REC               0x50000000
      #define msf__V4REC               0x60000000
      #define msf__UNIREC              0x80000000
   //----------------------------------------------------------------
   // Boot system information
   uint16_t   reserv;

   //----------------------------------------------------------------
   // Application information
   uint16_t   techNumber;
   uint16_t   softwareCRC32Low; //CRC32 of application programm
   uint32_t   softwareSize;     //size of application programm
   uint32_t   serialNumber;
   uint16_t   softwareCRC32High;

   //----------------------------------------------------------------
   // Naming, string information
   uint8_t    Signature[devSIGNATURE_SIZE];
   uint8_t    nc0;
   uint8_t    Name[devNAME_SIZE];
   uint8_t    nc1;
   //----------------------------------------------------------------
   // VersionInfo
   struct versionNumber appVersion;
   //----------------------------------------------------------------
   // Bootloader VersionInfo
   struct versionNumber bootVersion;
   //----------------------------------------------------------------
   uint8_t    reserv3[20];
#ifdef __arm__arm__
   m3Signature(){for(int i=0;i<sizeof(m3Signature);i++)((char*)(&ID))[i]=0;}
   void     clear(){for(int i=0;i<sizeof(m3Signature);i++)((char*)(&ID))[i]=0;}
#endif
};


struct __attribute__ ((packed)) m4Signature{
   //----------------------------------------------------------------
   // System | Hardware information
   uint16_t   ID;
   uint16_t   tablesCRC16;
   uint32_t   flags;
      #define msf__BloadSupport        0x00000001
      #define msf__ApplicationStarted  0x00000002
      #define msf__ApplicationCorrupt  0x00000004
      #define msf__ApplicationIncompat 0x00000008
      #define msf__NoApplication       0x00000010
      #define msf__HARDWARE_ERROR      0x00000100
      #define msf__LBA1_CMD_SUPPORT    0x00010000
      #define msf__MultiLangSupport    0x00020000
      #define msf__Console_SUPPORT     0x00040000
      #define msf__AccessControl       0x00080000
      #define msf__DataHashing         0x00100000
      #define msf__SIDA1_CMD_SUPPORT   0x00200000
      #define msf__Want_be_Master      0x08000000 // flag set if device want to be bus master
      #define msf__V2REC               0x40000000
      #define msf__V3REC               0x50000000
      #define msf__V4REC               0x60000000
   //----------------------------------------------------------------
   // Naming, string information
   uint8_t    Signature[devSIGNATURE_SIZE];
   uint8_t    nc0;
   uint8_t    Name[devNAME_SIZE];
   uint8_t    nc1;
   //----------------------------------------------------------------
   // Numeral information
   uint32_t   techNumber;
   uint32_t   serialNumber;
   //----------------------------------------------------------------
   // Application information
   uint32_t   softwareID;
   uint32_t   softwareSize;     //size of application programm
   uint32_t   softwareCRC32;
   struct   versionNumber softwareVersion;
   uint8_t    reserv[16];
   //----------------------------------------------------------------
   // Bootloader VersionInfo
   struct versionNumber bootVersion;
   //----------------------------------------------------------------
#ifdef __arm__arm__
   m4Signature(){for(int i=0;i<sizeof(m4Signature);i++)((char*)(&ID))[i]=0; flags=msf__V4REC;}
   void     clear(){for(int i=0;i<sizeof(m4Signature);i++)((char*)(&ID))[i]=0;flags=msf__V4REC;}
#endif
};



#endif
